use {crate::*, miniunsigned::*};

// `u16` or `u32`.
pub trait CyclicPolyHash: Unsigned {
    const TABLE: [Self; 256];
}

// Lower bytes from the random numbers ripped from `cyclic-poly-23`.
impl CyclicPolyHash for u16 {
    const TABLE: [Self; 256] = [
        0x6109, 0x638d, 0xa762, 0x2cce, 0x9bf1, 0xc409, 0xa4aa, 0x94e1, 0x1579, 0x0574, 0xfaed,
        0xc343, 0x7957, 0xb00a, 0xff77, 0x1b8a, 0x512a, 0x43da, 0xa23a, 0x7b6c, 0x89c7, 0x8dbf,
        0x63a1, 0x1be9, 0x55a1, 0x4a29, 0x1d28, 0x8254, 0xd6e9, 0x7fca, 0x6d53, 0x3927, 0x60d9,
        0x26b6, 0x88a4, 0x2063, 0x4fcc, 0x6c4d, 0x5a5b, 0x8ff1, 0x2575, 0x1c66, 0x8c14, 0xe2a5,
        0xd526, 0xa89e, 0x2640, 0x1c3d, 0xb698, 0x8ac5, 0xae1a, 0x0498, 0x2c7e, 0x415c, 0x198f,
        0x9418, 0x6128, 0x0d66, 0x0f4c, 0xfec8, 0x9e8b, 0x24a7, 0xdde0, 0xfb3d, 0xed15, 0x6bc0,
        0xbc0c, 0xf898, 0xafbf, 0xd214, 0x9d8b, 0xd4d8, 0xc63c, 0xcc0c, 0xa4f6, 0x373a, 0x4f48,
        0x9bb2, 0x8c21, 0x97fa, 0x916a, 0xa1c9, 0x5518, 0xf6d2, 0x98f2, 0x34b9, 0x2898, 0xc6c4,
        0xb659, 0xd6f9, 0xa1ea, 0xf699, 0x3022, 0x36b2, 0xbb21, 0x8502, 0xe635, 0xad5c, 0x3a34,
        0xec08, 0xc44d, 0x2451, 0x1f4a, 0x34cd, 0xb50f, 0x26f9, 0x8801, 0xfb48, 0xa1aa, 0x7554,
        0xac8c, 0x783b, 0x2af1, 0x3fa9, 0x31a6, 0x0c0f, 0x9768, 0x2982, 0xe257, 0x5d73, 0xd0cc,
        0xb494, 0x5b4b, 0x83ed, 0xf084, 0x4fb5, 0x97a2, 0xa128, 0xf282, 0xa47f, 0x328e, 0x0cbc,
        0x77af, 0xcf68, 0x5bd3, 0x4cc1, 0xa82e, 0x007b, 0x5aa1, 0xb40e, 0x69ce, 0x491d, 0x8117,
        0xf782, 0x6278, 0xfaaf, 0x73b3, 0xf39f, 0x970d, 0x5aa9, 0x4474, 0x3e4d, 0xd10f, 0xa847,
        0x10be, 0x2ba3, 0xf3ec, 0x7bc4, 0x7325, 0xa3b2, 0x4cd9, 0x044b, 0x8122, 0x5565, 0x9899,
        0x7739, 0xb942, 0x65b9, 0xfe60, 0xcac2, 0xc32e, 0x57f8, 0xf523, 0x013b, 0xacdc, 0x126d,
        0x8060, 0x3f74, 0x32cd, 0x1af8, 0xf458, 0x5201, 0x15ab, 0x8965, 0xb17c, 0x945a, 0x404b,
        0xef36, 0x4a67, 0x73fe, 0x0658, 0x9a61, 0x29ce, 0xaa6a, 0xb2ad, 0x7b75, 0x8eb1, 0x4634,
        0xa362, 0xfedf, 0x432b, 0x31be, 0x81c1, 0x37f0, 0xa3e4, 0x6ab2, 0xf59f, 0xccc9, 0x032c,
        0xa355, 0x1f86, 0xe3df, 0x8ef6, 0x2022, 0xd347, 0x27df, 0x2983, 0xbf4a, 0xdb01, 0x04f4,
        0x1721, 0x5b38, 0xdbdb, 0xb2d1, 0x8bb3, 0xd5a3, 0x6485, 0x7578, 0x9978, 0xa8bc, 0xb4c3,
        0x6c1f, 0x2adc, 0x31c1, 0x7fe0, 0xbf50, 0x809d, 0xdc89, 0xe13f, 0xdc27, 0x2e7a, 0x56fe,
        0x0442, 0x2f57, 0x415a, 0xf74c, 0x9e1a, 0x0981, 0x13fd, 0x6f5a, 0x45c4, 0xc200, 0x1b99,
        0x7ca3, 0x77c3, 0xd8f6,
    ];
}

// Random numbers ripped from `cyclic-poly-23`.
impl CyclicPolyHash for u32 {
    const TABLE: [Self; 256] = [
        0x28e06109, 0xfbfa638d, 0x9792a762, 0x6b392cce, 0x3b739bf1, 0x60a1c409, 0x0b82a4aa,
        0xb56894e1, 0x77c21579, 0x19030574, 0x8fa0faed, 0x1a15c343, 0xa6447957, 0x833eb00a,
        0x13faff77, 0xf1521b8a, 0xa37e512a, 0x793943da, 0xea04a23a, 0xc0da7b6c, 0x789689c7,
        0xc6568dbf, 0x14f263a1, 0x15441be9, 0xf19d55a1, 0x86054a29, 0x5a951d28, 0xd6b08254,
        0xb855d6e9, 0x4afa7fca, 0xbf276d53, 0x87e53927, 0x938a60d9, 0x661926b6, 0x8d2d88a4,
        0x709b2063, 0xd56c4fcc, 0x73eb6c4d, 0x25f15a5b, 0xf9418ff1, 0xb0ba2575, 0x47171c66,
        0xe9958c14, 0x45c3e2a5, 0x5067d526, 0xd833a89e, 0x596b2640, 0x9ea51c3d, 0xa923b698,
        0x33208ac5, 0x060fae1a, 0x2f400498, 0x9cc02c7e, 0x59ae415c, 0x0553198f, 0xb2a69418,
        0xbe016128, 0x78920d66, 0x46440f4c, 0xe0f3fec8, 0x176b9e8b, 0x73ac24a7, 0xe9e4dde0,
        0x499afb3d, 0xcf58ed15, 0xefb96bc0, 0xb50abc0c, 0x27bdf898, 0xb0f9afbf, 0x9fd8d214,
        0x41c89d8b, 0x23e2d4d8, 0x13d7c63c, 0x22cacc0c, 0x3272a4f6, 0x4a99373a, 0xc68f4f48,
        0x23c99bb2, 0xf9a68c21, 0x2b6497fa, 0x540d916a, 0xff89a1c9, 0xb0645518, 0x554bf6d2,
        0xe57e98f2, 0xe01034b9, 0xab942898, 0x2c67c6c4, 0xd478b659, 0xdfe7d6f9, 0xf4a0a1ea,
        0x28bff699, 0x802f3022, 0x708536b2, 0xedbdbb21, 0xb4128502, 0x853ce635, 0x8fe8ad5c,
        0x69583a34, 0x457dec08, 0xa073c44d, 0x9d8e2451, 0x1f7f1f4a, 0x7b2334cd, 0x8371b50f,
        0xde8526f9, 0xd49c8801, 0x5999fb48, 0x2350a1aa, 0x61177554, 0xa6b9ac8c, 0x9472783b,
        0x57832af1, 0x1cd33fa9, 0x061531a6, 0x24e00c0f, 0xdee89768, 0xab6e2982, 0xf072e257,
        0x4a805d73, 0xa24ed0cc, 0x5176b494, 0xb3c45b4b, 0x198d83ed, 0x2b72f084, 0xd75e4fb5,
        0x7b9497a2, 0x9ea0a128, 0x9161f282, 0xf31ba47f, 0x437f328e, 0xd5e00cbc, 0x2b1d77af,
        0x8a77cf68, 0xa5cf5bd3, 0x98014cc1, 0x9017a82e, 0xcebb007b, 0x19f95aa1, 0x67a7b40e,
        0x704b69ce, 0x454a491d, 0xe0838117, 0x9debf782, 0x57e26278, 0x974cfaaf, 0xf0c673b3,
        0x4283f39f, 0x0a61970d, 0x53b35aa9, 0x33544474, 0x88d23e4d, 0x5b76d10f, 0xcf3aa847,
        0xd79c10be, 0x13bc2ba3, 0xb840f3ec, 0x42c77bc4, 0xfd237325, 0x69e3a3b2, 0x266a4cd9,
        0x576b044b, 0xdb458122, 0x497a5565, 0x857e9899, 0x5e1d7739, 0xaf65b942, 0x788b65b9,
        0xc189fe60, 0xb5e1cac2, 0xfdbfc32e, 0x302e57f8, 0x74b7f523, 0x3200013b, 0x8661acdc,
        0x4567126d, 0x00f08060, 0xa8893f74, 0x2c2532cd, 0x082b1af8, 0x3718f458, 0xadde5201,
        0xb55d15ab, 0x025a8965, 0x09d2b17c, 0x89f2945a, 0xf208404b, 0x1b91ef36, 0xc4df4a67,
        0xfa3c73fe, 0x4d0a0658, 0x19929a61, 0x672029ce, 0x894daa6a, 0xe90bb2ad, 0x0ab17b75,
        0xe86b8eb1, 0xbece4634, 0x1951a362, 0x097bfedf, 0x407b432b, 0x694631be, 0x24bc81c1,
        0x8e9137f0, 0xf521a3e4, 0x4c166ab2, 0x7386f59f, 0x8fbbccc9, 0x99ae032c, 0xfaeea355,
        0x086b1f86, 0xc99ce3df, 0x7cce8ef6, 0xa8ca2022, 0x6142d347, 0x9ee327df, 0x317b2983,
        0x42cdbf4a, 0x9f2edb01, 0x727e04f4, 0x478f1721, 0xdf465b38, 0xe3badbdb, 0x9104b2d1,
        0x47238bb3, 0x50c6d5a3, 0x92796485, 0xe0657578, 0xf3149978, 0x8083a8bc, 0x17c4b4c3,
        0x00346c1f, 0xbe782adc, 0x531e31c1, 0x735d7fe0, 0x28febf50, 0xa654809d, 0x46a1dc89,
        0x3ff5e13f, 0x13fcdc27, 0xf7b72e7a, 0x606656fe, 0x1aa20442, 0x3d752f57, 0xd9a2415a,
        0x3c32f74c, 0x26919e1a, 0x81270981, 0x36b813fd, 0x02b06f5a, 0xab8b45c4, 0x4b62c200,
        0x33891b99, 0x12de7ca3, 0x2c2377c3, 0x8051d8f6,
    ];
}

pub struct HashCyclicPoly<H, S, W> {
    hash: H,
    reverse: [H; 256],
    #[cfg(debug_assertions)]
    window: W,
    #[cfg(debug_assertions)]
    _marker: std::marker::PhantomData<S>,
    #[cfg(not(debug_assertions))]
    _marker: std::marker::PhantomData<(S, W)>,
}

impl<H, S, W> HashCyclicPoly<H, S, W>
where
    H: CyclicPolyHash,
    S: Unsigned,
    W: NonZero<S>,
{
    fn new(window: W) -> Self {
        let mut reverse = [H::zero(); 256];

        let num_rotate_bits = (window.get().to_usize() & u32::MAX as usize) as u32;

        for (r, &t) in reverse.iter_mut().zip(H::TABLE.iter()) {
            *r = t.rotate_left(num_rotate_bits);
        }
        Self {
            hash: H::zero(),
            reverse,
            #[cfg(debug_assertions)]
            window,
            _marker: Default::default(),
        }
    }

    fn hash_bytes(&mut self, bytes: &[u8]) {
        self.hash = bytes.iter().fold(self.hash, |hash, &b| {
            hash.rotate_left(1) ^ H::TABLE[b as usize]
        });
    }

    fn roll_hash(&mut self, old_byte: u8, new_byte: u8) {
        self.hash = self.hash.rotate_left(1) ^ H::TABLE[new_byte as usize];
        self.hash = self.hash ^ self.reverse[old_byte as usize];
    }

    fn hash(&self) -> H {
        self.hash
    }
}

impl<H, S, W> RollingHashImpl<H, S, W> for HashCyclicPoly<H, S, W>
where
    H: CyclicPolyHash,
    S: Unsigned,
    W: NonZero<S>,
{
    fn new(window: W) -> Self {
        Self::new(window)
    }

    fn hash_bytes(&mut self, bytes: &[u8]) {
        #[cfg(debug_assertions)]
        {
            debug_assert_eq!(bytes.len(), self.window.get().to_usize());
        }

        self.hash_bytes(bytes)
    }

    fn roll_hash(&mut self, old_byte: u8, new_byte: u8) {
        self.roll_hash(old_byte, new_byte);
    }

    fn hash(&self) -> H {
        self.hash()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Compare the 32bit hash to the reference implementation in the [`cyclic-poly-23`](https://crates.io/crates/cyclic-poly-23) crate.
    #[test]
    fn cyclic_poly_test() {
        let bytes = [0u8, 1, 2, 3, 4, 5, 6, 7];

        let window = NonZeroU32::new(4).unwrap();

        let hash = RollingHashCyclicPoly32::<'_>::new(&bytes, window);

        let mut hash_reference =
            cyclic_poly_23::CyclicPoly32::from_block(&bytes[..window.get() as usize]);

        let mut iter = hash.into_iter().enumerate();

        while let Some((offset, hash)) = iter.next() {
            assert_eq!(hash, hash_reference.value());

            if (offset + window.get() as usize) < bytes.len() {
                let old_byte = bytes[offset];
                let new_byte = bytes[offset + window.get() as usize];
                hash_reference.rotate(old_byte, new_byte);
            }
        }
    }
}
